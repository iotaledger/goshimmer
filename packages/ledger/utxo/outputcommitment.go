package utxo

import (
	"context"

	"github.com/cockroachdb/errors"
	"github.com/iotaledger/hive.go/cerrors"
	"github.com/iotaledger/hive.go/generics/lo"
	"github.com/iotaledger/hive.go/serix"
	"github.com/iotaledger/hive.go/types"
	"gitlab.com/NebulousLabs/merkletree/merkletree-blake"
	"golang.org/x/crypto/blake2b"
)

// region OutputCommitment /////////////////////////////////////////////////////////////////////////////////////////////

// OutputCommitment represents a cryptographic commitment to the Outputs generated by a Transaction.
type OutputCommitment struct {
	StateRoot       types.Identifier `serix:"0"`
	NumberOfOutputs uint64           `serix:"1"`

	merkleTree *merkletree.Tree
}

// FromOutputs creates a new OutputCommitment from the given Outputs.
func (o *OutputCommitment) FromOutputs(outputs ...Output) (err error) {
	o.NumberOfOutputs = uint64(len(outputs))
	o.merkleTree = merkletree.New()

	for _, output := range outputs {
		serializedOutput, serializationErr := output.Bytes()
		if serializationErr != nil {
			return errors.Errorf("failed to serialize Output: %w", serializationErr)
		}

		o.merkleTree.Push(serializedOutput)
	}
	o.StateRoot = o.merkleTree.Root()

	return nil
}

// Proof generates a proof that the Output at the given index is included in the OutputCommitment.
func (o *OutputCommitment) Proof(outputIndex uint64) (proof *OutputCommitmentProof, err error) {
	if o.merkleTree == nil {
		return nil, errors.Errorf("proofs can only be created when initialized with outputs: %w", cerrors.ErrFatal)
	}

	if err = o.merkleTree.SetIndex(outputIndex); err != nil {
		return nil, errors.Errorf("unable to set index: %w", err)
	}

	proof = &OutputCommitmentProof{
		OutputCommitment: new(OutputCommitment),
	}
	proof.OutputCommitment.StateRoot, _, proof.ProofSet, proof.ProofIndex, proof.OutputCommitment.NumberOfOutputs = o.merkleTree.Prove()

	return proof, nil
}

// Bytes returns a serialized version of the OutputCommitment.
func (o *OutputCommitment) Bytes() (serialized []byte) {
	return lo.PanicOnErr(serix.DefaultAPI.Encode(context.Background(), o))
}

// endregion ///////////////////////////////////////////////////////////////////////////////////////////////////////////

// region OutputCommitmentProof ////////////////////////////////////////////////////////////////////////////////////////

// OutputCommitmentProof is a cryptographic proof that an Output is part of an OutputCommitment.
type OutputCommitmentProof struct {
	OutputCommitment *OutputCommitment `serix:"0"`
	ProofSet         [][32]byte        `serix:"1,lengthPrefixType=uint32"`
	ProofIndex       uint64            `serix:"2"`
}

// Validate validates the proof and checks if the given Output is indeed part of the OutputCommitment that is referenced
// in the proof.
func (o *OutputCommitmentProof) Validate(output Output) (err error) {
	outputBytes, err := output.Bytes()
	if err != nil {
		return errors.Errorf("failed to serialize Output: %w", err)
	}

	outputHash := blake2b.Sum256(outputBytes)
	if o.ProofSet[0] != outputHash {
		return errors.Errorf("invalid proof: output hash %x does not match expected value of %x: %w", outputHash, o.ProofSet[0], cerrors.ErrFatal)
	}

	if !merkletree.VerifyProof(o.OutputCommitment.StateRoot, o.ProofSet, o.ProofIndex, o.OutputCommitment.NumberOfOutputs) {
		return errors.Errorf("invalid proof - merkle proof is invalid: %w", cerrors.ErrFatal)
	}

	return nil
}

// Bytes returns a serialized version of the OutputCommitmentProof.
func (o *OutputCommitmentProof) Bytes() (bytes []byte) {
	return lo.PanicOnErr(serix.DefaultAPI.Encode(context.Background(), o))
}

// endregion ///////////////////////////////////////////////////////////////////////////////////////////////////////////
