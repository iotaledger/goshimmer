package utxo

import (
	"github.com/cockroachdb/errors"
	"github.com/iotaledger/hive.go/cerrors"
	"github.com/iotaledger/hive.go/marshalutil"
	"github.com/iotaledger/hive.go/types"
	"gitlab.com/NebulousLabs/merkletree/merkletree-blake"
	"golang.org/x/crypto/blake2b"
)

// region OutputCommitment /////////////////////////////////////////////////////////////////////////////////////////////

// OutputCommitment represents a cryptographic commitment to the Outputs generated by a Transaction.
type OutputCommitment struct {
	StateRoot       types.Identifier
	NumberOfOutputs uint64

	merkleTree *merkletree.Tree
}

// FromOutputs creates a new OutputCommitment from the given Outputs.
func (o *OutputCommitment) FromOutputs(outputs ...Output) {
	o.NumberOfOutputs = uint64(len(outputs))
	o.merkleTree = merkletree.New()

	for _, output := range outputs {
		o.merkleTree.Push(output.Bytes())
	}
	o.StateRoot = o.merkleTree.Root()
}

// Proof generates a proof that the Output at the given index is included in the OutputCommitment.
func (o *OutputCommitment) Proof(outputIndex uint64) (proof *OutputCommitmentProof, err error) {
	if o.merkleTree == nil {
		return nil, errors.Errorf("proofs can only be created when initialized with outputs: %w", cerrors.ErrFatal)
	}

	if err = o.merkleTree.SetIndex(outputIndex); err != nil {
		return nil, errors.Errorf("unable to set index: %w", err)
	}

	proof = &OutputCommitmentProof{
		OutputCommitment: new(OutputCommitment),
	}
	proof.OutputCommitment.StateRoot, _, proof.ProofSet, proof.ProofIndex, proof.OutputCommitment.NumberOfOutputs = o.merkleTree.Prove()

	return proof, nil
}

// Bytes returns a serialized version of the OutputCommitment.
func (o *OutputCommitment) Bytes() (serialized []byte) {
	return marshalutil.New().
		Write(o.StateRoot).
		WriteUint64(o.NumberOfOutputs).
		Bytes()
}

// endregion ///////////////////////////////////////////////////////////////////////////////////////////////////////////

// region OutputCommitmentProof ////////////////////////////////////////////////////////////////////////////////////////

// OutputCommitmentProof is a cryptographic proof that an Output is part of an OutputCommitment.
type OutputCommitmentProof struct {
	OutputCommitment *OutputCommitment
	ProofSet         [][32]byte
	ProofIndex       uint64
}

// Validate validates the proof and checks if the given Output is indeed part of the OutputCommitment that is referenced
// in the proof.
func (o *OutputCommitmentProof) Validate(output Output) (err error) {
	outputHash := blake2b.Sum256(output.Bytes())
	if o.ProofSet[0] != outputHash {
		return errors.Errorf("invalid proof: output hash %x does not match expected value of %x: %w", outputHash, o.ProofSet[0], cerrors.ErrFatal)
	}

	if !merkletree.VerifyProof(o.OutputCommitment.StateRoot, o.ProofSet, o.ProofIndex, o.OutputCommitment.NumberOfOutputs) {
		return errors.Errorf("invalid proof - merkle proof is invalid: %w", cerrors.ErrFatal)
	}

	return nil
}

// endregion ///////////////////////////////////////////////////////////////////////////////////////////////////////////
